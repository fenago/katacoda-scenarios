In the previous chapters, we did some serious magic in order to build
our application. To be able to run the builds, we executed the following
command:

```
oc create -f https://raw.githubusercontent.com/wildfly-swarm/sti-wildflyswarm/master/1.0/wildflyswarm-sti-all.json
```

In previous chapters, when we wanted to build our application, we
invoked the following command:

```
oc new-app wildflyswarm-10-centos7~https://github.com/PacktPublishing/Hands-On-Cloud-Development-with-WildFly.git (...)
```

After a lot of mysterious stuff had happened (as indicated by growing
logs), we were able to see our application working. Now, it's time to
explain what actually happened under the hood. Let's get to know
OpenShift builds.

In general, an OpenShift build is an operation that transforms input
parameters into a resulting object that is used to start an application.
In most cases, the build will transform the source code into an image
that will be later deployed on the cluster.

The details of the build process operation depend on the build type
(about which we will learn in a moment), but the general algorithm looks
as follows:

1.  The build container starts from the build image
2.  Sources from all the inputs are being injected into the container
3.  The build scripts are being run
4.  The output docker image is created

The new concept that is being introduced here is the build container.
Let's take a look at it a little bit closer. What actually is its
purpose? The container in which you are building your application has to
contain all the libraries, tools, and runtimes that are necessary to
build and run your application. For example, if you use the WildFly AS
builder image, it will contain Java, Maven, and WildFly runtimes among
others. After the application is built, the same image is used as a base
for the Docker image that will be deployed to OpenShift. Speaking
precisely, your application will be added as another layer on top of the
builder image, resulting in a runnable image with your application. The
good news here is that although you can easily create an image yourself,
in most cases those images will be created by the tool provider. 

The input types can be provided from any resources, such as GitHub
repositories, existing images, and Dockerfile config. All the sources
that you provide are unpacked and merged together in the build
directory, which will be processed by the builder image during the
build. The option that we will use (and actually have used a few times
already) in this book is GitHub repositories.

As we mentioned previously, the precise way in which a build works
depends on the build type. You will be able to define the type of build
by specifying the build strategy. You can create images using Docker,
Source-to-image of custom builds. The build type that is most
interesting for us is the source-to-image build, which we will explain
in the next section. 

There is also another type of build—`pipeline`. The
`pipeline` build is connected to the Jenkins CI server and
allows you to create a fully featured **Continuous Deployment** (**CD**)
`pipeline`. We will describe this kind of build thoroughly in
the second part of this chapter.

Let's turn to the source-to-image build now.
