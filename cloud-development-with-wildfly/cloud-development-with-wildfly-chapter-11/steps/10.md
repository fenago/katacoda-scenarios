In order to learn Hystrix behavior in practice, we are going to extend
customer-gateway service so that it uses Hystrix for its invocations.
Later, we are going to make one of our services artificially
unresponsive and see how Hystrix behaves. Let's start.

### Note

Examples reference: `chapter11/customer-gateway-hystrix`.

Firstly, we are going to add Hystrix dependency to the
`pom.xml`:

```
(...)

<dependency>
    <groupId>com.netflix.hystrix</groupId>
    <artifactId>hystrix-core</artifactId>
    <version>${version.hystrix}</version>
</dependency>

(...)
```

The circuit breaker command is implemented by extending the
`com.netflix.hystrix.HystrixCommand` class. Let's take a look
at its usage at the concrete example of our `PricingProxy`:

```
(...)

@ApplicationScoped
public class PricingProxy {

    (...)

    //1
    private class GetPriceCommand extends HystrixCommand<Response> {

private final String itemId;

        //2
        public GetPriceCommand(String itemId) {
            //3
            super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey("pricing-service"));
            this.itemId = itemId;
        }

        @Override
        //4
        protected Response run() {
            //5
            Client client = ClientBuilder.newClient();
            WebTarget target = client.target(targetPath + "/price/" + itemId);
            return target.request(MediaType.APPLICATION_JSON).get();
        }
    }
}
```

The command has to extend the abstract `HystrixCommand` class
(1). The class has to be parameterized with a type that will be returned
as the command result. In our example, it will be the JAX-RS response
class—the same as we used in our raw invocation.

The class takes the itemId parameter as an argument (2), which will be
used in the invocation.

As you can see in the constructor code, we have provided
`HystrixCommandGroupKey` parameter to it (3).
`HystrixCommand` constructors allow you to provide a
combination of three arguments: `HystrixCommandGroupKey`,
`HystrixThreadPoolKey`, and the timeout. The two enum
parameters are used for command grouping: the commands with the same
group key will belong to the same group and will be grouped together for
the purpose of reporting, alerting, and monitoring. The thread pool key
specifies the commands that belong to the same Hystrix thread pool used
by the bulkhead algorithm. When the thread pool key is not enabled, the
group key is used as the thread pool identifier.

As a result, in our example all the `pricingService`
invocation commands will belong to the same group and will use their own
thread pool. The third argument in the
`HystrixCommand `constructors is the timeout of the
invocation. If one is not provided, the default timeout is used.

We have to extend the `run` method of the HystrixCommand class
(4). This method will be invoked when the command is executed. As you
can see (5), the content of the method is the same as the code of the
proxy in our raw invocation.

Now, let's take a look at how to execute the command:

```
(...)

@ApplicationScoped
public class PricingProxy {

    private final String targetPath = System.getProperty("proxy.pricing.url");

    //1
    public Price getPrice(String itemId){
        //2
        return new GetPriceCommand(itemId).execute().readEntity(Price.class);
    }

    (...)
}
```

The getPrice method of the proxy (1) creates the command object (2) and
invokes the `execute()` method on it. This results in the
execution of the whole circuit breaker algorithm described in the
theoretical section. Let's invoke the catalog/item method now and
measure the time of its invocation:

![](https://github.com/athertahir/katacoda-scenarios/raw/master/cloud-development-with-wildfly/cloud-development-with-wildfly-chapter-11/images/29384454-c196-4bde-a320-c59e7d67200f.png)

There is no difference; the invocation is executed immediately without
any errors. Now, let's make `pricingService` artificially
unresponsive.

### Note

Examples reference: `chapter11/pricing-service-misbehave`.

In order to do that we are going to make the service wait a specified
amount of time before returning a result:

```
package org.packt.swarm.petstore.pricing;

import org.packt.swarm.petstore.pricing.model.Price;

import javax.enterprise.context.ApplicationScoped;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.LockSupport;

@ApplicationScoped
public class PricingService {

@PersistenceContext(unitName = "PricingPU")
private EntityManager em;

    public Price findByItemId(String itemId) {
        //1
        LockSupport.parkNanos(TimeUnit.SECONDS.toNanos(5));
        return em.createNamedQuery("Price.findByItemId", Price.class).setParameter("itemId", itemId).getSingleResult();
}
}
```

Let's deploy the new service to the cloud and retry an invocation. The
result is as follows:

![](https://github.com/athertahir/katacoda-scenarios/raw/master/cloud-development-with-wildfly/cloud-development-with-wildfly-chapter-11/images/8654cbf5-4b34-4d34-94b2-93719f3912e2.png)

As you will have noticed in the preceding screenshot, the invocation has
resulted in failure. The circuit breaker was open, and there was a
thread available in the thread pool. As a result, the invocation was
performed, but it exceeded the default Hystrix timeout which equals 1
second.

To confirm this, let's look at the logs:

![](https://github.com/athertahir/katacoda-scenarios/raw/master/cloud-development-with-wildfly/cloud-development-with-wildfly-chapter-11/images/b3901360-3fff-4dd3-88f4-2eb14dab355c.png)

Hystrix does not lie here: the timeout was exceeded and we have
implemented no fallback. We will do in a second, but before that let's
learn how to modify Hystrix properties.

If you want to modify the configuration of `HystrixCommand`,
you have to use the constructor with the `Setter` argument.
This class allows you to configure all the constructor arguments
described previously. Apart from that, the class allows you to provide
the configuration properties for different aspects of the circuit
breaker behavior. The exhaustive list of such properties is described in
the Hystrix documentation. Here, we will present a few example
modifications. Let's start with the circuit breaker timeout:

```
(...)
private class GetPriceCommand extends HystrixCommand<Response> {

private final String itemId;

    public GetPriceCommand(String itemId) {
        //1
        super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey("pricing-service"))
                .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()
        //2
                        .withExecutionTimeoutInMilliseconds(100)));
        this.itemId = itemId;
}

@Override
protected Response run() {
        Client client = ClientBuilder.newClient();
WebTarget target = client.target(targetPath + "/price/" + itemId);
```

```
        return target.request(MediaType.APPLICATION_JSON).get();
}
}
(...)
```

The preceding code modifies our command class in order to shorten the
invocation timeout to 500 milliseconds. The `Setter` class is
used, and the`CommandGroupKey` is set in the same way as in
the examples before (1). In order to modify the configuration, we have
added `HystrixCommandProperites.Setter` with the appropriate
configuration (2). Now, let's take a look at the following result:

![](https://github.com/athertahir/katacoda-scenarios/raw/master/cloud-development-with-wildfly/cloud-development-with-wildfly-chapter-11/images/e6a09941-ebc5-4e91-b4ac-bb3f3372f542.png)

Let's reconfigure the application to note the behavior of the
bulkheading algorithm; we will increase the timeout and reduce the
number of threads:

```
(...)private class GetPriceCommand extends HystrixCommand<Response> {

private final String itemId;

    public GetPriceCommand(String itemId) {
super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey("pricing-service"))
//1.andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter().withCoreSize(3));
        this.itemId = itemId;
}

@Override
protected Response run() {
        Client client = ClientBuilder.newClient();
WebTarget target = client.target(targetPath + "/price/" + itemId);
        return target.request(MediaType.APPLICATION_JSON).get();
}
}
(...)
```

In order to do that, another setter (this time, the
`HystrixThreadPoolProperties` setter) has to be created (1).

The result is as follows:

![](https://github.com/athertahir/katacoda-scenarios/raw/master/cloud-development-with-wildfly/cloud-development-with-wildfly-chapter-11/images/aff251d6-c591-4329-881f-f5d5669754b7.png)

As you will have noticed in the preceding screenshot, the first three
invocations have obtained their threads and were blocked. The fourth
thread returned immediately as there are no more threads in the thread
pool.

Finally, let's open the circuit. If we run the code in a bash loop and
look into the log, we will note the following result:

![](https://github.com/athertahir/katacoda-scenarios/raw/master/cloud-development-with-wildfly/cloud-development-with-wildfly-chapter-11/images/657cfb35-511d-4541-ad63-eb3e40027438.png)

Finally, let's implement the fallback:

```
(...)
private class CreatePaymentCommand extends HystrixCommand<Response> {

private final Payment payment;

    public CreatePaymentCommand(Payment payment) {
super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(SERVICE_NAME))
                              .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()
                                      .withExecutionTimeoutInMilliseconds(100)));
        this.payment = payment;
}

@Override
protected Response run() {
        Client client = ClientBuilder.newClient();
WebTarget target = client.target(targetPath + "/payment");
        return target.request(MediaType.APPLICATION_JSON).post(Entity.json(payment));
}

    @Override
    //1
    protected Response getFallback() {
//2
        return Response.status(Response.Status.SERVICE_UNAVAILABLE).build();
    }
}

(...)
```

In order to implement the fallback, you have to override the
`getFallback` method (1). In our example, we have returned the
`SERVICE_UNAVAILABLE` exception whenever the
`paymentService` is unreachable (2).

We can now reimplement the`PetstoreService` so that it creates
a meaningful exception whenever such situations occur:

```
public String buy(int customerId){
    Cart cart = cartProxy.getCart(customerId);

Order order = createOrderFromCart(customerId, cart);
    int orderId  = orderProxy.createOrder(order);

Payment payment = new Payment();
payment.setMerchantId(Constants.MERCHANT_ID);
payment.setDescription(String.format("ORDER_ID: %s", orderId));
payment.setAmount(order.getPrice());

Response response =  paymentProxy.createPayment(payment);

    if(response.getStatus() == Response.Status.SERVICE_UNAVAILABLE.getStatusCode()){
        throw new RuntimeException("Payment service unreachable");
    }

return (String) response.readEntity(String.class);
}
```

This will be the result of an invocation:

![](https://github.com/athertahir/katacoda-scenarios/raw/master/cloud-development-with-wildfly/cloud-development-with-wildfly-chapter-11/images/f7958235-ccb0-4803-bcf1-7c63a6111ffa.png)
