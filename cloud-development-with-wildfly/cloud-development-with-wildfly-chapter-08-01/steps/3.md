Deployments
-----------

* * * * *

Let's examine what happens under the hood during deployment of our
services. We are going to continue work on an example from the previous
chapter.

### Note

Examples reference:
`chapter8/catalog-service-openshift-load-balancing`.

You have to open the web console, and navigate to **`Applications`**|
**`Deployments`** | **`catalog-service`**:

![](https://github.com/athertahir/katacoda-scenarios/raw/master/cloud-development-with-wildfly/cloud-development-with-wildfly-chapter-08-01/images/5a3013fc-3600-42df-8c79-b7df7ca87507.png)

Now we will be able to see the deployment configuration. This is the
graphical representation of OpenShift's
`DeploymentConfiguration` object.

As you learned in [Chapter
6](https://subscription.packtpub.com/book/web_development/9781786462374/6),
*Deploying Applications on the Cloud with OpenShift*, OpenShift adds
another layer on top of Kubernetes to provide a more convenient and
productive programmer experience. It does that, among other things, by
extending the object model of Kubernetes.
`DeploymentConfiguration` and **`Deployments`** are OpenShift
objects that extend the Kubernetes object model.

The `DeploymentConfiguration` object manages the creation of
the **`Deployments`** objects. It contains all the necessary information
to create **`Deployments`**, which, as its name suggests, represents an
instance of deployment. When one of the Deployments triggers happens,
the old deployment object is replaced by the new one. All of the
deployment objects are based on `DeploymentConfiguration`.
**`Deployments`**, among others, encapsulate
Kubernetes's `ReplicationController` object. Let's understand
it in greater detail.

### Learning the basics of ReplicationController

`ReplicationController`contains the following information: the
pod template, selector, and the number of replicas. Let's examine those
further.

The pod template is basically a pod definition. It contains information
about the containers, volumes, ports, and labels. Every pod created by
this replication controller will be started using this pod template. The
selector is used to determine which pods are governed by
this`ReplicationController`. Finally, the number of replicas
is the number of pods that we want to be running. 

Kubernetes works in the following way: it monitors the current state of
the cluster, and if that state is different from the desired state it
takes actions so that the desired state is restored. The same thing
happens with `ReplicationControllers`.
`ReplicationController` continuously monitors the number of
pods that are associated with it. If the number of the pods is different
than the desired number, it starts or stops pods so that the desired
state is restored. The pod is started using the pod template.

Let's examine the `ReplicationController` that Kubernetes
created for our catalog-service. To do this, we will use the CLI:

![](https://github.com/athertahir/katacoda-scenarios/raw/master/cloud-development-with-wildfly/cloud-development-with-wildfly-chapter-08-01/images/3e85eb8d-fc81-4b76-944a-638e99691ef0.png)

As you will notice in the preceding screenshot, there are three
replication controllers created for **`catalog-service`**. This is the
case because of each redeployment of the application results in the
creation of a new deployment object with its own replication controller.
Note that only **`catalog-service-3`** has the desired number of
instances greater than **`0`**—the previous deployments have been made
inactive when the new deployment was taking place.

Let's take a look at the description of the active controller:

![](https://github.com/athertahir/katacoda-scenarios/raw/master/cloud-development-with-wildfly/cloud-development-with-wildfly-chapter-08-01/images/ed9b513f-2dd8-40b7-856c-74a8e49f5835.png)

The selector has threelabels: app, deployment, and deployment-config. It
unambiguously identifies the pods associated with the given deployment.

### Note

Exactly the same labels are used in the pod template. Other parts of the
pod template contain the image from which the container is built, and
the environment variables that we provided during the creation of the
service. Finally, the number of current and desired replicas is set, by
default, to one. 

OK. So how do we scale our service so that it runs on more than one
instance? Let's move to the web console again. We need to navigate to
**`Application`** | **`Deployments`** again and enter the
**`catalog-service`** configuration:

![](https://github.com/athertahir/katacoda-scenarios/raw/master/cloud-development-with-wildfly/cloud-development-with-wildfly-chapter-08-01/images/c663a822-fa73-448a-ac3d-2578ca3039ff.png)

To scale the **`catalog-service`** application, we have to adjust the
**`Replicas`** field to the number of instances that we want to
have. That's it.

When we look at the `ReplicationControllers` in the
`oc`, we will see the following information:

![](https://github.com/athertahir/katacoda-scenarios/raw/master/cloud-development-with-wildfly/cloud-development-with-wildfly-chapter-08-01/images/1bfc0f17-4260-4260-9827-439b8e0c8f99.png)

The number of pods has been changed to **`5`**. As we saw in
the `oc` output, additional pods have been started and we now
have five instances. Let's check in the console (navigate
to **`Applications`** | **`Pods`**):

![](https://github.com/athertahir/katacoda-scenarios/raw/master/cloud-development-with-wildfly/cloud-development-with-wildfly-chapter-08-01/images/cb9be74c-1507-43fa-91fc-fcfab266f2a9.png)

OpenShift has indeed scaled our application according to our needs. 

After having worked with OpenShift for some time, you should be able to
see what we meant in [Chapter
6](https://subscription.packtpub.com/book/web_development/9781786462374/6),
*Deploying Applications on the Cloud with OpenShift*, when we wrote that
OpenShift builds an effective and easy-to-use application development
environment on top of Kubernetes. The preceding example showed how it
works very well: Kubernetes is responsible for making sure that the
state of the cluster equals the description provided. In the preceding
example, this description is provided by a
`ReplicationController` object (which is part of the
Kubernetes object model). Note, however, that OpenShift has abstracted
away all the nitty-gritty details from us. We have only provided the
information such as the address of the code repository or number of
replicas that we want to have. The OpenShift layer abstracts away the
technical details of cluster configuration and provides us with
convenient, easy-to-use tools, which allow the programmer to concentrate
on the development.

Let's return to our main topic. The next thing that we will configure is
**load balancing**.
