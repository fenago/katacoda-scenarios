The catalog-service with database
---------------------------------

* * * * *

You have learned the essential knowledge to understand how to work with
persistent storage in the OpenShift cloud. Now, let's take a look at
this with a practical example. Let's update our **`catalog-service`**
deployment so that it connects to the database.

### Configuring PostgreSQL database

Now, we are ready to deploy the database. Open your web console and
click on the **`Add to the Project`** button. We will search for the
PostgreSQL project:

![](https://github.com/athertahir/katacoda-scenarios/raw/master/cloud-development-with-wildfly/cloud-development-with-wildfly-chapter-07/images/89ebc85e-07e2-4a29-b215-23d1a3a613b6.png)

The search results in a number of options; we need to choose the data
store option:

![](https://github.com/athertahir/katacoda-scenarios/raw/master/cloud-development-with-wildfly/cloud-development-with-wildfly-chapter-07/images/b706481d-f1ee-40e0-a7d3-4aa0d0ddf026.png)

When you click on the **`Select`** button, the following form opens:

![](https://github.com/athertahir/katacoda-scenarios/raw/master/cloud-development-with-wildfly/cloud-development-with-wildfly-chapter-07/images/f53c736b-9db9-4740-806f-369495693c3b.png)

We changed the name of the database server and the name of the database
instance to `catalogdb`. For convenience purposes, we have set
both the user and password to catalog.

We will also override **`Labels`**:

![](https://github.com/athertahir/katacoda-scenarios/raw/master/cloud-development-with-wildfly/cloud-development-with-wildfly-chapter-07/images/d65848e0-ef93-4205-b18e-b5f3f4f8cef9.png)

We will use a bunch of database containers for our different services.
As a result, we can't use standard application and template labels. We
change them to **`catalogdb-template`** and `catalogdb`.

After we have done that, we are ready to create an application; let's
click on the **`Create`** button at the bottom of the page.

We have to wait for the moment till the pod has been started. Let's
click on the **`Overview page`** button and further on **`postgresql`**
deployment; we have to wait till there is one replica active:

![](https://github.com/athertahir/katacoda-scenarios/raw/master/cloud-development-with-wildfly/cloud-development-with-wildfly-chapter-07/images/4685cdc3-fcf2-411a-8650-f03fc95945b6.png)

The application is running. Let's fill our database with a number of
pets so that we can test our service behavior. To do that we need to get
access to the console of the container on which the database run. In
order to achieve that we have to go to applications/pods menu, choose
the pod on which PostgreSQL runs, and the terminal button:

![](https://github.com/athertahir/katacoda-scenarios/raw/master/cloud-development-with-wildfly/cloud-development-with-wildfly-chapter-07/images/fcd77f2f-5f0e-429c-9ded-ea9bffc4797c.png)

Let's fill the database now. Let's log into the user directory and
create the SQL script there:


```
cd
vi items.sql
```

The script is very similar to the load scripts that we created in
previous applications:


```
DROP TABLE IF EXISTS ITEM;

CREATE TABLE ITEM (id serial PRIMARY KEY, item_id varchar, name varchar, description varchar, quantity smallint);

INSERT INTO ITEM(item_id, name, description, quantity) VALUES ('dbf67f4d-f1c9-4fd4-96a8-65ee1a22b9ff',  'turtle', 'Slow friendly reptile. Let your busy self see how it spends 100 years of his life laying on sand and swimming.', 5);
INSERT INTO ITEM(item_id, name, description, quantity) VALUES ('fc7ee3ea-8f82-4144-bcc8-9a71f4d871bd', 'hamster', 'Energetic rodent - great as a first pet. Will be your only inmate that takes his fitness training serviously.', 10);
INSERT INTO ITEM(item_id, name, description, quantity) VALUES ('725dfad2-0b4d-455c-9385-b46c9f356e9b','goldfish', 'With its beauty it will be the decoration of you aquarium. Likes gourmet fish feed and postmodern poetry.', 3);
INSERT INTO ITEM(item_id, name, description, quantity) VALUES ('a2aa1ca7-add8-4aae-b361-b7f92d82c3f5', 'lion', 'Loves playing the tag and cuddling with other animals and people.', 9);
```

Please note, that we have changed the convention here. Instead of using
names as item identifiers, we start using UIDs we will be the consistent
ID for pets in the whole application. Finally, we are going to execute
the script:


```
psql -U catalog catalogdb < items.sql
```

The command above run PostgreSQL command line client. The
`-U` parameter specifies the user (catalog in our example) and
the `catalogdb` parameter specifies the schema on which the
client must operate.

### Inspecting the volumes

In order to take a look at how the database is configured, let's use
`cli`:


```
oc describe dc/catalogdb
```

Let's return to our example.

### Updating catalog-service

We have to reconfigure our **`catalog-service`** again so that it works
with the PostgreSQL database.

### Note

Examples reference: `chapter7/catalog-service-openshift-postgresql`.

Let's start with the `pom.xml` changes—we have to add Postgres
dependency to it:


```
(...)

    <dependencies>
        (...)
        <dependency>
            <groupId>org.wildfly.swarm</groupId>
            <artifactId>jpa</artifactId>
            <version>${version.wildfly.swarm}</version>
        </dependency>
        <!-- 1 -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <version>${version.postgresql}</version>
        </dependency>

    </dependencies>

(...)
```

We have changed the database driver from `h2` to
`PostgreSQL` (1).

Let's change the datasource configuration:


```
swarm:
  datasources:
    data-sources:
      CatalogDS:
       driver-name: postgresql
connection-url: jdbc:postgresql://catalogdb.petstore.svc/catalogdb
user-name: catalog
password: catalog
jdbc-drivers:
      postgresql:
        driver-class-name: org.postgresql.Driver
xa-datasource-name: org.postgresql.xa.PGXADataSource
driver-module-name: org.postgresql.jdbc
```

We have to reconfigure the JDBC driver to user `postgresql`
classes and reconfigure the datasource, so that it contains the data of
our application. The meaning of catalogdb.petstore.svc address will be
explained in the next chapter.

As in the previous database examples, we have to provide the
`persistence` file:


```
<?xml version="1.0" encoding="UTF-8"?>
<persistence
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
version="2.1"
xmlns="http://xmlns.jcp.org/xml/ns/persistence"
xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd">
    <persistence-unit name="CatalogPU" transaction-type="JTA">
        <jta-data-source>java:jboss/datasources/CatalogDS</jta-data-source>
    </persistence-unit>
</persistence>
```

Finally, we have to add the `postgreSQL` JDBC module to the
application...

![](https://github.com/athertahir/katacoda-scenarios/raw/master/cloud-development-with-wildfly/cloud-development-with-wildfly-chapter-07/images/50e79c68-b600-4ae9-807a-64eae30effc0.png)

With the following contents:


```
<?xml version="1.0" encoding="UTF-8"?>
<module xmlns="urn:jboss:module:1.5" name="org.postgresql.jdbc">

  <resources>
<artifact name="org.postgresql:postgresql:${version.postgresql}"/>
  </resources>
<dependencies>
    <module name="javax.api"/>
    <module name="javax.transaction.api"/>
  </dependencies>
</module>
```

OK, now that we have reconfigured our **`catalog-service`**, it is time
for interesting stuff. Let's deploy our application to OpenShift.

We will use the source-to-image build again as we did in the last
chapter:

`oc new-app wildflyswarm-10-centos7~https://github.com/PacktPublishing/Hands-On-Cloud-Development-with-WildFly.git --context-dir=chapter7/catalog-service-openshift-postgresql/ --name=catalog-service`{{execute}}

We have to wait till our fat-JAR has started. To verify that, we may
take a look at the log of the pod on which the application was started:

![](https://github.com/athertahir/katacoda-scenarios/raw/master/cloud-development-with-wildfly/cloud-development-with-wildfly-chapter-07/images/40c24a25-f870-420d-bc9e-dadbf92faba1.png)

As in the preceding example, we have to create a route. After doing
that, let's find out the address of **`catalog-service`** visible from
outside the cluster:

![](https://github.com/athertahir/katacoda-scenarios/raw/master/cloud-development-with-wildfly/cloud-development-with-wildfly-chapter-07/images/59e64cf5-5ab7-4528-8955-3422d599a878.png)

Let's copy the route name and use `curl` to check whether we
can get pet information using **`catalog-service`**:

![](https://github.com/athertahir/katacoda-scenarios/raw/master/cloud-development-with-wildfly/cloud-development-with-wildfly-chapter-07/images/197e1c02-243b-4487-93e0-f291087a33a2.png)

It works. Let's extend our service now so that it is able to persist
data to the database.

Let's extend our `CatalogService`:


```
package org.packt.swarm.petstore.catalog;

import org.packt.swarm.petstore.catalog.model.Item;

import javax.enterprise.context.ApplicationScoped;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.transaction.Transactional;
import java.util.List;
import java.util.UUID;


@ApplicationScoped
public class CatalogService {

@PersistenceContext(unitName = "CatalogPU")
private EntityManager em;

    public Item searchById(String itemId) {
return em.createNamedQuery("Item.findById", Item.class).setParameter("itemId", itemId).getSingleResult();
}

    //1
    @Transactional
    public void add(Item item){
        //2
        item.setItemId(UUID.randomUUID().toString());
        em.persist(item);
    }

    //3
    public List<Item> getAll() {
        return em.createNamedQuery("Item.findAll", Item.class).getResultList();
    }

}
```

We have extended the service with the `add` method (1). Note
that the method is transactional and generates UUID for the items in the
store (2). We have also added a method that lists all the items in the
store (3). Note that we would need also to add NamedQuery for that:


```
(...)

@Entity
@Table(name = "item")
@NamedQueries({
@NamedQuery(name="Item.findById",
query="SELECT i FROM Item i WHERE i.itemId = :itemId"),
        @NamedQuery(name="Item.findAll",
                query="SELECT i FROM Item i")
})
public class Item {
(...)
```

We also have to add the `POST` method to
the`CatalogResource`:


```
package org.packt.swarm.petstore.catalog;

import org.packt.swarm.petstore.catalog.model.Item;

import javax.inject.Inject;
import javax.ws.rs.Consumes;
import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import java.util.List;

@Path("/")
public class CatalogResource {

@Inject
private CatalogService catalogService;

@GET
    @Path("item/{itemId}")
@Produces(MediaType.APPLICATION_JSON)
public Response searchById(@PathParam("itemId") String itemId) {
try {
            Item item = catalogService.searchById(itemId);
            return Response.ok(item).build();
} catch (Exception e) {
            e.printStackTrace();
            return Response.status(Response.Status.BAD_REQUEST).entity(e.getMessage()).build();
}
    }

    //1
    @POST
    @Path("item")
    //2
    @Produces(MediaType.APPLICATION_JSON)
    //3
    @Consumes(MediaType.APPLICATION_JSON)
    public Response addNew(Item item) {
        try {
            catalogService.add(item);
            return Response.ok(item).build();
        } catch (Exception e) {
            return Response.status(Response.Status.BAD_REQUEST).entity(e.getMessage()).build();
        }
    }

    //2
    @GET
    @Path("item")
    @Produces(MediaType.APPLICATION_JSON)
    @Consumes(MediaType.APPLICATION_JSON)
    public Response getAll() {
        try {
            List<Item> item = catalogService.getAll();
            return Response.ok(item).build();
        } catch (Exception e) {
            return Response.status(Response.Status.BAD_REQUEST).entity(e.getMessage()).build();
        }
    }

}
```

We have implemented the `addNew` method, which uses the
`CatalogService` instance to add an `Item` object(1)
to the database. As you will have noticed in the preceding code, both
the `Request` parameter and `Response` are JSON
objects. They are parsed automatically by a server; the only thing that
we must do is annotate the method with the `@Produces` (2) and
`@Consumes` (3) annotations. In the method, we use the
`catalogService` to store a given Item object. Finally, we
return either the `ok` response (5) or an error response (6)
based on the result of the store operation.

We have also implemented `getAll` method which will allow us
to request information about all the pets in the store (2).

After the application is ready, you have to commit the changed files and
push them to GitHub. When you do this, you can enter the web console and
trigger the build of the updated service. In order to do it, you have to
click on **`Build | `****`Build in the Webconsole`**, select the
**`catalog-service`**, and click on the **`Start Build`** button in the
top-right corner:

![](https://github.com/athertahir/katacoda-scenarios/raw/master/cloud-development-with-wildfly/cloud-development-with-wildfly-chapter-07/images/a0ea7e0d-42e8-4d0e-b63e-37c6048b431e.png)

After the application starts, we have to wait till it has been deployed
in the cloud. Let's use `curl` to `POST` new Item in
our store:

![](https://github.com/athertahir/katacoda-scenarios/raw/master/cloud-development-with-wildfly/cloud-development-with-wildfly-chapter-07/images/cc0bad72-be66-4374-9f9e-f998c2ecb05e.png)

Everything seems fine, so let's check what items are available in the
store using the request that we have just implemented:

![](https://github.com/athertahir/katacoda-scenarios/raw/master/cloud-development-with-wildfly/cloud-development-with-wildfly-chapter-07/images/991d558d-ebb0-4704-a53c-c14af2694710.png)

There are three rabbits in our database. Our service is working
correctly inside the OpenShift cluster.

We may now check that the storage is indeed persistent. Let's get into
the web console and terminate both catalog-service and database pods. In
order to do that, enter web console, click
**`Applications |`****`Pods`** and choose the **`database`** pod. Later
click on **`Actions`** in the right, upper corner and choose
**`Delete`**. Repeat those actions for **`catalog-service`** pod. After
both pods have been restarted (you can monitor that in
**`Applications | `****`Pods`** view), you can again list all items. You
should be able to see extract the same result as on the preceding
screenshot.
