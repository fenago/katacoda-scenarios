Creating complex stacks of applications with templates
Another useful kind of OpenShift resource is a template. Instead of creating resources one-by-one – for example, a pod, service, and route – templates allow you to create multiple objects at once with a single CLI command. More than that —they may include parameters that can be optional, or default to values either static or generated in accordance with specific rules. In a sense, they are similar to Docker Compose or OpenStack Heat—all of these provide the facility to create entire application stacks from the ground up. With templates, the cluster administrator can provide developers with the ability to deploy multi-tier applications with all dependent services.

By default, OpenShift comes installed with quite a few default templates, called Instant App and Quick Start templates. They can be used to deploy runtime environments based on various languages and frameworks, such as Ruby on Rails (Ruby), Django (Python), and CakePHP (PHP). They also include templates for SQL and NoSQL database engines with persistent storage, which includes PersistentVolumeClaims as one of the objects to provide persistence of data.

For this exercise, you will not require admin privileges, so you can login as a regular user:


`oc login -u alice`{{execute}}
Default templates are created in the openshift project during installation. You can see them by running the following command:


`oc get template -n openshift | cut -d' ' -f1`{{execute}}

NAME
3scale-gateway
amp-apicast-wildcard-router
amp-pvc
cakephp-mysql-example
cakephp-mysql-persistent
dancer-mysql-example
dancer-mysql-persistent
django-psql-example
django-psql-persistent
dotnet-example
dotnet-pgsql-persistent
dotnet-runtime-example
httpd-example
...
<output omitted>
...
We used the cut command to exclude descriptions and other information for the sake of brevity, but you can run this command without cut to see the full output.

Note
Both MiniShift and OpenShift, when installed by the Ansible installer, have default templates installed out-of-the-box but, in the case of containerized quick installation, you may have to create them manually from YAML definitions located in the roles/openshift_examples/files/examples/ directory of the Ansible installer.

To get a list of parameters that are supported by a particular template, use the process command:


`oc process --parameters mariadb-persistent -n openshift`{{execute}}

NAME                   DESCRIPTION       GENERATOR       VALUE
MEMORY_LIMIT           ...                               512Mi
NAMESPACE              ...                               openshift
DATABASE_SERVICE_NAME  ...                               mariadb
MYSQL_USER             ...               expression      user[A-Z0-9]{3}
MYSQL_PASSWORD         ...               expression      [a-zA-Z0-9]{16}
MYSQL_ROOT_PASSWORD    ...               expression      [a-zA-Z0-9]{16}
MYSQL_DATABASE         ...                               sampledb
MARIADB_VERSION        ...                               10.2
VOLUME_CAPACITY        ...                               1Gi
Note
We left out descriptions of the parameters to make the output more readable.

As you may have noticed, some parameters have dynamic default values, generated by expressions loosely based on Perl Compatible Regular Expressions (PCREs).

The process command generates default values from all dynamic expressions, making the template definition ready to be used for creating resources, which is done either by piping its output to the create command or by running the new-app command—we will get to that in a few moments. For now, let's use that command to see a List of objects to be created:


`oc process openshift//mariadb-persistent`{{execute}}
{
    "kind": "List",
    "apiVersion": "v1",
    "metadata": {},
    "items": [
        {
            "apiVersion": "v1",
            "kind": "Secret",
            ...
            <output omitted>
            ...
            "stringData": {
                "database-name": "sampledb",
                "database-password": "tYuwInpmocV1Q1uy",
                "database-root-password": "icq5jd8bfFPWXbaK",
                "database-user": "userC7A"
            }
        },
        ...
        <output omitted>
        ...
    ]
}

Note: The process command allows for an alternate syntax, <NAMESPACE>//<TEMPLATE>. We used it here for demonstration purposes, but you are free to use the more familiar -n <NAMESPACE> notation.

The list is quite long, so we only provided an excerpt showing the Secret resource that contains all generated sensitive values that are to be used for template instantiation.

To make things clearer, let's take a look at the expressions for generating those values in the raw template definition:


`oc export template mariadb-persistent -n openshift`{{execute}}

apiVersion: v1
kind: Template
...
<output omitted>
...
objects:
- apiVersion: v1
  kind: Secret
  ...
  <output omitted>
  ... 
  stringData:
    database-name: ${MYSQL_DATABASE}
    database-password: ${MYSQL_PASSWORD}
    database-root-password: ${MYSQL_ROOT_PASSWORD}
    database-user: ${MYSQL_USER}
...
<output omitted>
...
parameters:
...
<output omitted>
...
- description: Username for MariaDB user that will be used for accessing the database.
  displayName: MariaDB Connection Username
from: user[A-Z0-9]{3}
  generate: expression
  name: MYSQL_USER
  required: true
...
<output omitted>
...
- description: Name of the MariaDB database accessed.
  displayName: MariaDB Database Name
  name: MYSQL_DATABASE
  required: true
value: sampledb
...
<output omitted>
...
You may have noticed, for example, that MYSQL_DATABASE is sampledb, while MYSQL_USER starts with the string user with three alphanumeric characters, just as we saw in the previous listing.

Note
To learn more about how to construct regular expressions for dynamic parameters, refer to http://perldoc.perl.org/perlre.html.

Now, we will create our own simple template. Create a new template definition with the following contents:


`cat example-template.yml`{{execute}}
kind: Template
apiVersion: v1
metadata:
  name: example-template
labels:
  role: web
message: You chose to deploy ${WEB_SERVER}
objects:
  - kind: Pod
    apiVersion: v1
    metadata:
      name: example-pod
    spec:
      containers:
        - name: ${WEB_SERVER}
          image: ${WEB_SERVER}
  - kind: Service
    apiVersion: v1
    metadata:
      name: example-svc
    spec:
      ports:
        - port: 80
      selector:
        role: web
  - kind: Route
    apiVersion: v1
    metadata:
      name: example-route
    spec:
      to:
        kind: Service
        name: example-svc
parameters:
  - name: WEB_SERVER
    displayName: Web Server
    description: Web server image to use
    value: nginx
Note
Though in our case the message parameter is used in quite a rudimentary way, in more complex templates, its purpose is to tell the user how to use the template—what usernames, passwords, URLs, and so on were generated.

This template can be used to create three resources:

- A pod running a web server, which you can choose by supplying the WEB_SERVER parameter. By default, it's nginx.
- A service proxying incoming traffic to the pod.
- A route for external access.

We can process that definition right away and pass the resulting list of resources to the create command, but a common strategy is to create a template from its definition first:
`oc create -f example-template.yml`{{execute}}

Let's try to process it:
`oc process --parameters example-template`{{execute}}

NAME       DESCRIPTION             GENERATOR         VALUE
WEB_SERVER Web server image to use                   nginx

You can see the only parameter with the default value and description that you defined earlier.

Now, it's time to create a stack of resources from our template. This can be done by either piping the output of the process command to the create command, which we mentioned previously, or by using the new-app command. Let's start with the former approach:


`oc process example-template | oc create -f -`{{execute}}


As you can see, the create command just takes the list of resources and submits requests for their creation one-by-one to the API, so the output is similar to what you would see if you created three separate resource definitions and created resources from them manually.

But another way to instantiate a template gives you more information about what is going on. Let's delete the created resources first:


`oc delete all --all`{{execute}}
route "example-route" deleted
pod "example-pod" deleted
service "example-svc" deleted
We don't have to delete the template as it's not going to change. Now, we can use the new-app command:


`oc new-app --template=example-template`{{execute}}
--> Deploying template "myproject/example-template" to project myproject

     example-template
     ---------
You chose to deploy nginx

     * With parameters:
        * Web Server=nginx

--> Creating resources ...
    pod "example-pod" created
    service "example-svc" created
    route "example-route" created
--> Success
    Access your application via route 'example-route-advanced.openshift.example.com' 
    Run 'oc status' to view your app.

`oc status
In project advanced on server https://172.24.0.11:8443

http://example-route-advanced.openshift.example.com (svc/example-svc)
  pod/example-pod runs nginx


1 info identified, use 'oc status -v' to see details.
As you can see, we created the pod, fronted it with the service, and exposed it through the route in just a single command. Notice that you don't need to run the oc get route  command to find out what URL your application is accessible through—it all shows in the output.

Let's see if our web server is reachable through curl:


`curl -IH 'Host: example-route-advanced.openshift.example.com' 127.0.0.1`{{execute}}

HTTP/1.1 200 OK
Server: nginx/1.15.1
...
<output omitted>
...
Note
We used the -I parameter of the curl command to see only response headers, which is enough to check the responsiveness of the server and ensure that it doesn't dump raw HTML into the console. Also, just as before, we used -H option to request a specific application from OpenShift's router.

You can easily delete all of the resources and instantiate the template again, but this time with another web server image, such as Apache:


`oc delete all --all`{{execute}}
route "example-route" deleted
pod "example-pod" deleted
service "example-svc" deleted

`oc new-app --template=example-template -p WEB_SERVER=httpd`{{execute}}
--> Deploying template "myproject/example-template" to project myproject

     example-template
     ---------
You chose to deploy httpd
...
<output omitted>
...
    Access your application via route 'example-route-advanced.openshift.example.com' 
    Run 'oc status' to view your app.

`curl -H 'Host: example-route-advanced.openshift.example.com' 127.0.0.1`{{execute}}

<html><body><h1>It works!</h1></body></html>

`curl -IH 'Host: example-route-advanced.openshift.example.com' 127.0.0.1`{{execute}}

HTTP/1.1 200 OK
Date: Thu, 19 Jul 2018 00:59:47 GMT
Server: Apache/2.4.34 (Unix)
...
<output omitted>
...


That's it—one parameter and you have a different web server deployed for you in a matter of seconds.

You can also perform a reverse operation—creating a template from existing resources. To do that, use the export command:


`oc export all --as-template=exported-template > exported-template.yml
Let's delete our resources to prevent any conflicts:


`oc delete all --all`{{execute}}

route "example-route" deleted
pod "example-pod" deleted
service "example-svc" deleted
And recreate them from the exported template:


`oc new-app -f exported-template.yml`{{execute}}
--> Deploying template "advanced/exported-template" for "exported-template.yml" to project advanced

--> Creating resources ...
    route "example-route" created
    pod "example-pod" created
    service "example-svc" created
--> Success
    Access your application via route 'example-route-advanced.openshift.example.com' 
    Run 'oc status' to view your app.


Note: You might have noticed that the web server was exposed through the same URL as before. This is because the exported template was created from already instantiated resources with all parameters resolved to values, so OpenShift has no way of knowing which fields were parameterized. You can also infer this from the output of the process command, which will show you that all the fields are already initialized. So, strictly speaking, this isn't a fully reverse operation, but it can be used for backups.

Now that we are finished, let's do a clean-up:
`oc delete all --all`{{execute}}


`oc delete template/example-template`{{execute}}